{"meta":{"title":"西二旗","subtitle":null,"description":null,"author":"nameless","url":"http://www.songyuqiang.com"},"pages":[],"posts":[{"title":"句柄泄漏","slug":"handle_leak","date":"2018-08-06T12:40:27.000Z","updated":"2018-09-02T14:18:33.000Z","comments":true,"path":"2018/08/06/handle_leak/","link":"","permalink":"http://www.songyuqiang.com/2018/08/06/handle_leak/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334public static String execLsof() &#123; StringBuilder outputBuilder = new StringBuilder(); BufferedReader bufferedReader = null; java.lang.Process process = null; int totalLine = 0; int pid = Process.myPid(); try &#123; //捕获日志 process = Runtime.getRuntime().exec(\"ls -al /proc/\" + pid + \"/fd\"); //将捕获内容转换为BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream())); String str; while ((str = bufferedReader.readLine()) != null) &#123; totalLine++; outputBuilder.append(str).append(\"\\n\"); &#125; &#125; catch (Throwable throwable) &#123; &#125; finally &#123; if (bufferedReader != null) &#123; try &#123; bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (process != null) &#123; process.destroy(); &#125; &#125; return outputBuilder.toString(); &#125;","categories":[],"tags":[]},{"title":"proxy","slug":"proxy","date":"2018-07-10T12:54:28.000Z","updated":"2018-07-10T12:57:10.000Z","comments":true,"path":"2018/07/10/proxy/","link":"","permalink":"http://www.songyuqiang.com/2018/07/10/proxy/","excerpt":"","text":"我们的视频缓存，是起了一个本地服务，专门用来做缓存这件事的，比如这个本地服务是127.0.0.1:10000 每次拉缓存的时候，要先ping一下它，连通了，通过这个服务拿缓存数据 然后有的用户反馈，每次看完视频重播，还是走流量 我查了半天发现，假如挂了全局代理的话 那我ping本地的那个127.0.0.1:10000就ping到代理服务器的10000端口上了，那个端口没有这个服务，导致我的缓存就失效了 目前想到的解决办法是,强制这个端口不走代理 1new OkHttpClient.Builder().proxy(Proxy.NO_PROXY);","categories":[],"tags":[]},{"title":"leetcode443","slug":"leetcode443","date":"2018-03-25T06:32:48.000Z","updated":"2018-09-02T14:22:15.000Z","comments":true,"path":"2018/03/25/leetcode443/","link":"","permalink":"http://www.songyuqiang.com/2018/03/25/leetcode443/","excerpt":"","text":"上上周面试的时候让手写了一道比较基础的题目，涂涂改改了3遍才勉强通过，场面一度十分尴尬 回来又在leetcode上找到原题做了下，一遍就ac了，而且居然“runtime beats 100.00 % of golang submissions.” 看来手写算法这个技能还是需要练习一下，第一是要锻炼临场思考问题的能力，第二就是尽量摆脱对IDE的依赖性 题目如下，比较基础的字符串压缩12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( \"fmt\")/* Given an array of characters, compress it in-place.The length after compression must always be smaller than or equal to the original array.Every element of the array should be a character (not int) of length 1.After you are done modifying the input array in-place, return the new length of the array.Follow up:Could you solve it using only O(1) extra space?Example 1:Input:[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]Output:Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]Explanation:\"aa\" is replaced by \"a2\". \"bb\" is replaced by \"b2\". \"ccc\" is replaced by \"c3\".Example 2:Input:[\"a\"]Output:Return 1, and the first 1 characters of the input array should be: [\"a\"]Explanation:Nothing is replaced.Example 3:Input:[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]Output:Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].Explanation:Since the character \"a\" does not repeat, it is not compressed. \"bbbbbbbbbbbb\" is replaced by \"b12\".Notice each digit has it's own entry in the array.Note:All characters have an ASCII value in [35, 126].1 &lt;= len(chars) &lt;= 1000. */func compress(chars []byte) int &#123; if chars == nil &#123; return 0 &#125; if len(chars) == 1 &#123; return 1 &#125; var cur, count, arrCur int for cur &lt; len(chars) &#123; if cur+1 &lt; len(chars) &amp;&amp; chars[cur] == chars[cur+1] &#123; count++ &#125; else &#123; count++ if count == 1 &#123; chars[arrCur] = chars[cur] arrCur++ &#125; else &#123; chars[arrCur] = chars[cur] countStr := []byte(fmt.Sprintf(\"%v\", count)) for i := len(countStr); i &gt; 0; i-- &#123; //fmt.Printf(\"%v %v\", len(countStr), i) chars[arrCur+i] = countStr[i-1] &#125; //fmt.Printf(\"%v\", arrCur) arrCur += len(countStr) + 1 &#125; count = 0 &#125; cur++ &#125; return arrCur&#125;func main() &#123; arr := []byte(\"abbbbbccc\") index := compress(arr[0:]) for _, v := range arr[0:index] &#123; fmt.Printf(\"%v\", string(v)) &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"180312-180314","slug":"180312-180314","date":"2018-03-14T15:13:50.000Z","updated":"2018-03-14T15:53:31.000Z","comments":true,"path":"2018/03/14/180312-180314/","link":"","permalink":"http://www.songyuqiang.com/2018/03/14/180312-180314/","excerpt":"","text":"记录一下今天遇到的几个问题 JNI 调用so lib的native方法,提示\bJNI function cannot resolve 然而编译后发现，项目运行正常，\b调研了一番后定位了是IDE的问题，Eclipse和AS都会出现，在开启了NDK support后，APT只能定位到c,cpp代码中的方法，而并不能很好地定位so lib中的方法，导致IDE报红 解决方法，目前已知的就两个，要么无视这个编译期error，要么关掉ndk support 在做仿微信的可以下拉返回的ImagePreviewer的时候, 下拉的事件和PhotoView的zoom事件冲突 解决方法 //todo RecyclerView嵌套的页面,如果Recyclerview能够接收焦点，会在接收到焦点的时候，自动将屏幕滑动到顶部 解决方法 设置不让RecyclerView接收焦点,这个操作并不会影响它的点击事件 与此同时，还必须让recyclerView的容器可以接收焦点12subRecyclerView.setNestedScrollingEnabled(false);subRecyclerViewParent.setFocusableInTouchMode(true); RecyclerView嵌套的页面,滑动时失去fling效果 1subRecyclerView.setNestedScrollingEnabled(false); 实际上，在项目中，应该避免RecycerView的嵌套，这会导致很多问题,例如焦点，高度固定，sub item无法复用等 一个比较好的解决方法,是应该划分item type的粒度，使用同一个recyclerView，自定义LayoutManager来实现复杂类型的页面 这种方法的难点主要在于，增删元素计算position十分繁琐 为了解决这个问题，仔细学习了一下阿里v-layout的代码 //todo 关于hashCode和equals的实现, Effective\bJava中主要提出了两方面的观点 基于里氏替换原则,一个可以被继承的基类的equals和hashCode方法，在子类中也应该是工作正常的 123if (o == null || getClass() != o.getClass()) &#123; return false;&#125; 所以上面的代码，如果这个类不是一个final类，那么是不应该出现在equals方法中的，而应该用instanceOf 来代替getClass \b第二,hashCode和equals应该有一致性，就像FP中函数不应该有副作用，hashCode和equals不应该依赖于一个不可控的变量 1return getId() != null ? getId().equals(object.getId()) : object.getId() == null; 所以，上面的代码，如果getId的返回值不可控，那么就不应该出现在equals方法中 但是，有一个反例，在一些ORM框架，例如Hibernate，对象的equals和hashCode，在这个对象没有持久化前，\b是无法进行比较的 A business key does not have to be as solid as a database primary key candidate (see Section 13.1.3, “Considering object identity”). Immutable or unique properties are usually good candidates for a business key. The most obvious way is to implementequals()/hashCode() by comparing the identifier value of both objects. If the value is the same, both must be the same database row, because they are equal. If both are added to a Set, you will only have one element in the Set). Unfortunately, you cannot use that approach with generated identifiers. Hibernate will only assign identifier values to objects that are persistent; a newly created instance will not have any identifier value. Furthermore, if an instance is unsaved and currently in aSet, saving it will assign an identifier value to the object. If equals() and hashCode() are based on the identifier value, the hash code would change, breaking the contract of the Set. See the Hibernate website for a full discussion of this problem. This is not a Hibernate issue, but normal Java semantics of object identity and equality.It is recommended that you implementequals() and hashCode() using Business key equality. Business key equality means that the equals() method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a natural candidate key): 我觉得，从工程的角度考虑，Hibernate这样设计是对的，但是适用范围有局限性 假如我们要在一些对象持久化前，放到一个容器，如ArrayList中，那么如果equals和hashCode不能工作，add,get,indexOf就会全部失效了","categories":[],"tags":[]},{"title":"2018-week-10","slug":"lib","date":"2018-03-11T15:04:21.000Z","updated":"2018-03-11T16:01:06.000Z","comments":true,"path":"2018/03/11/lib/","link":"","permalink":"http://www.songyuqiang.com/2018/03/11/lib/","excerpt":"","text":"记录一下周末学习的碎片知识点，温故知新 https://zhuanlan.zhihu.com/p/21359984 为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中 .so 数量一致对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹 canvas双缓冲 123bufferBitmap = Bitmap.createBitmap(this.screenSize.x, this.screenSize.y, Bitmap.Config.ARGB_8888);//1 bufferCanvas = new Canvas(bufferBitmap);//2 canvas.drawBitmap(bufferBitmap, 0, 0, new Paint());//3 1 创建内存位图 2 创建绘图画布 3 在双缓冲中绘图，将自定义缓冲绘制到屏幕上 经过测试，绘制操作较少的时候，不使用缓冲效率较高，反之，canvas双缓冲可以大幅提高渲染速度 1234567891011121314151617private void drawOnBuffer(Canvas canvas) &#123; Paint paint = new Paint(); paint.setAntiAlias(true); canvas.drawColor(Color.WHITE); for (int n = 0; n &lt; 500; n++) &#123; //随机在绘图画布上绘制500个圆 int r = rand.nextInt(256); int g = rand.nextInt(256); int b = rand.nextInt(256); paint.setColor(Color.rgb(r, g, b)); int x = rand.nextInt(canvas.getWidth()); int y = rand.nextInt(canvas.getHeight()); int radius = rand.nextInt(100) + 20; canvas.drawCircle(x, y, radius, paint); Log.d(&quot;Circle&quot;, &quot;第n个&quot; + n); &#125; &#125; 在上面这个例子中，临界点大概在一次绘制500个圆 最近被问了很多次保活，为了加深认识，做了这几个方面的调研 问了一个在这方面做的比较多的朋友，现在还没堵上的大概有这么几个 针对不同api version，做不同的适配 JobService 相同id Service daemon 接一些应用市场，如google play的receiver decompile了几个国内比较大的应用，找到了一些相关代码片段1234567891011121314151617if (VERSION.SDK_INT &gt;= 21) &#123; ((JobScheduler) a.a.getSystemService(&quot;jobscheduler).cancel(2);&#125; else &#123; AlarmManager alarmManager = (AlarmManager) a.a.getSystemService(NotificationCompatApi24.CATEGORY_ALARM); if (b != null) &#123; alarmManager.cancel(b); &#125;&#125;public void onReceive(Context context, Intent intent) &#123; if (intent != null &amp;&amp; &quot;com.xxx.packagename&quot;.equals(intent.getAction())) &#123; WatchDogService.a(); &#125; else if (a.c) &#123; a.a(a.b); &#125;&#125; 关于保证客户端私钥安全，首先，这是一个伪命题，私钥存在客户端，无论如何都不安全 一个稍微靠谱的方式，将私钥写在native lib里，通过jni调用获取123456789101112131415161718static &#123; System.loadLibrary(&quot;private_config&quot;); native_init();&#125;public static String a(String str, JSONObject jSONObject) &#123; return a(str, jSONObject.toString());&#125;public static String a(String str, String str2) &#123; String generateSign = generateSign(str2.getBytes()); if (str.contains(&quot;?&quot;)) &#123; generateSign = &quot;&amp;sign=&quot; + generateSign; &#125; else &#123; generateSign = &quot;?sign=&quot; + generateSign; &#125; return str + generateSign;&#125;","categories":[],"tags":[]},{"title":"multipart","slug":"multipart","date":"2018-02-24T17:02:43.000Z","updated":"2018-02-28T14:03:58.000Z","comments":true,"path":"2018/02/25/multipart/","link":"","permalink":"http://www.songyuqiang.com/2018/02/25/multipart/","excerpt":"","text":"相比于Python,Ruby,使用Go编写的脚本直接生成可执行的二进制文件,可以直接在os上运行 于是尝试用Go写了一个 Android apk 打包上传fir.im的脚本,这样在团队中使用,可以不需要配脚本的编译运行环境,即插即用 首先,运行二进制的 gradlew 打包一个 apk 1234567cmd := exec.Command(&quot;./gradlew&quot;,&quot;assembleDebug&quot;)cmd.Stdout = os.Stdoutcmd.Stderr = os.Stderrif err := cmd.Run(); err != nil &#123; log.Fatalf(&quot;Error building Android app: %v&quot;,err) return&#125; 第二步,用 fir.im 的第三方服务发起一个HTTP GET \brequest,生成七牛的token 在解析返回的json时遇到了一些\b阻碍一开始没有找到类似 Java 中JsonObject optString\b的方法,使用Go,每解析一层都需要转成一个字典,导致代码十分繁琐 12var model map[string]stringerr = json.Unmarshal([]byte(*str), &amp;model) 于是采用了第二种方法,先根据json生成一个model,之后将返回的string映射到这个model上,\b这种方法明显方便了很多 1234567config := make(map[string]interface&#123;&#125;)config[&quot;type&quot;] = &quot;android&quot;config[&quot;bundle_id&quot;] = &quot;xxx&quot;config[&quot;api_token&quot;] = &quot;yyy&quot;bytesData, err := json.Marshal(config)reader := bytes.NewReader(bytesData)resp, err := http.Post(&quot;http://api.fir.im/apps&quot;,&quot;application/json&quot;, reader) 最后一步,使用form/data上传文件 这里学到一个知识,multipart表单上传多个 field 时,是将所有内容作为一个字符串写入到body中,结合 http/boundary 来分割不同part的内容 也就是说,正确的做法,应该是要先遍历所有 field 中的内容,生成出与这些内容没有发生交集的字符串,来作为分隔符 而不能简单的用如\\r\\n这样的方式来分隔,因为要上传的field中可能就包含了\\r\\n，导致分割的part不是我们想要的 123456789//go 标准库中生成boundary的方法 func randomBoundary() string &#123; var buf [30]byte _, err := io.ReadFull(rand.Reader, buf[:]) if err != nil &#123; panic(err) &#125; return fmt.Sprintf(&quot;%x&quot;, buf[:]) &#125; TODO : \bgradle 整合 go 二进制脚本","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.songyuqiang.com/tags/golang/"}]},{"title":"objective","slug":"objective","date":"2018-02-20T13:28:43.000Z","updated":"2018-02-28T14:03:12.000Z","comments":true,"path":"2018/02/20/objective/","link":"","permalink":"http://www.songyuqiang.com/2018/02/20/objective/","excerpt":"","text":"后天又要上班了… VSC真好用 果然定了很多计划最后啥都没干 leetcode078 subsets 怎么做都不会… 新的一年我只有一个目标 ==&gt; 早起 持续集成真好用… 还是需要一个好的显示器…","categories":[],"tags":[{"name":"trush","slug":"trush","permalink":"http://www.songyuqiang.com/tags/trush/"}]},{"title":"leetcode050","slug":"leetcode050","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode050/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode050/","excerpt":"","text":"12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Printf(&quot;%v&quot;, myPow(2, -2))&#125;func myPow(x float64, n int) float64 &#123; if n == 0 &#123; return 1.0 &#125; half := myPow(x, n/2) if n%2 == 0 &#123; return half * half &#125; else if n &gt; 0 &#123; return half * half * x &#125; else &#123; return half / x * half &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode008","slug":"leetcode008","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode008/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode008/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( &quot;fmt&quot;)func myAtoi(str string) int &#123; if str == &quot;&quot; &#123; return 0 &#125; bytes := []byte(str) var res int64 = 0 carry := 1 positive := true start := true startindex := 0 for i, v := range bytes &#123; if !start &amp;&amp; v == 32 &#123; return 0 &#125; if start &#123; if v==32 &#123; continue &#125; if v == &apos;-&apos; &#123; positive = false &#125; else if v &gt; 48 &amp;&amp; v &lt;= 57 &#123; startindex = i break &#125;else if v!=&apos;+&apos;&amp;&amp;v&lt;48||v&gt;57&#123; return 0 &#125; start = false &#125; else if !start &#123; fmt.Printf(&quot;begin %v&quot;, v) if v == 48 &#123; continue &#125; if v &gt; 48 &amp;&amp; v &lt;= 57 &#123; if i+1 &lt; len(bytes) &amp;&amp; bytes[i+1] == 32 &#123; return 0 &#125; else &#123; startindex = i break &#125; &#125; else &#123; return 0 &#125; &#125; &#125; //fmt.Printf(&quot;start %v %v \\n&quot;,startindex,bytes[startindex+1]) for i := len(bytes) - 1; i &gt;= startindex; i-- &#123; v := bytes[i] if v &gt;= 48 &amp;&amp; v &lt;= 57 &#123; var num int if positive &#123; num = int(v - 48) &#125; else &#123; num = -(int(v - 48)) &#125; res += int64(num * carry) if res &gt; 2147483647 &#123; return 2147483647 &#125; if res &lt; -2147483648 &#123; return -2147483648 &#125; carry *= 10 &#125; else if v == 32 &#123; res = 0 carry = 1 &#125; else &#123; res = 0 carry = 1 &#125; &#125; return int(res)&#125;func main() &#123; print(myAtoi(&quot;9223372036854775809&quot;))&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode009","slug":"leetcode009","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode009/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode009/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainfunc isPalindrome(x int) bool &#123; //carry := 1 //var arr []int if x &lt; 0 &#123; return false &#125; lens := 1 for x/(lens*10) != 0 &#123; lens *= 10 &#125; left := 1 right := lens for left &lt; right &#123; //fmt.Printf(&quot;%v %v \\n&quot;, (x / left), (x / lens)) if x/left%10 != x/right%10 &#123; return false &#125; left *= 10 right /= 10 &#125; /*for x/carry != 0 &#123; arr = append(arr, x/carry%10) carry *= 10 &#125; i := 0 j := len(arr) - 1 for i &lt; len(arr)-1 &amp;&amp; j &gt;= 0 &#123; //fmt.Printf(&quot;%v %v \\n&quot;, arr[i], arr[j]) if arr[i] != arr[j] &#123; return false &#125; i++ j-- &#125;*/ return true&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode011","slug":"leetcode011","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode011/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode011/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport &quot;fmt&quot;func main() &#123; println(maxArea([]int&#123;1,1&#125;))&#125;func maxArea(height []int) int &#123; var startIndex = 0 var endIndex = len(height) - 1 startHeight := height[0] endHeight := height[len(height)-1] var res = 0 if startHeight &gt; endHeight &#123; res = endHeight * (len(height)-1) endIndex-- &#125; else &#123; res = startHeight * (len(height)-1) startIndex++ &#125; fmt.Println(res) for startIndex &lt; endIndex &#123; startHeight := height[startIndex] endHeight := height[endIndex] var temp = 0 if startHeight &gt; endHeight &#123; temp = endHeight * (endIndex - startIndex) fmt.Println(temp, &quot; &quot;, endHeight, &quot; &quot;, endIndex, &quot; &quot;, startIndex) &#125; else &#123; temp = startHeight * (endIndex - startIndex) fmt.Println(temp, &quot; &quot;, startHeight, &quot; &quot;, endIndex, &quot; &quot;, startIndex) &#125; if temp &gt; res &#123; res = temp &#125; if startHeight &lt; endHeight &#123; startIndex++ &#125; else &#123; endIndex-- &#125; &#125; return res&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode013","slug":"leetcode013","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode013/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode013/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;%v&quot;, romanToInt(&quot;MDCCCLXXXIV&quot;))&#125;/*相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4正常使用时，连续的数字重复不得超过三次从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。反之，减去前一个数的两倍然后加上该数*/func romanToInt(s string) int &#123; var dic = make(map[rune]int) dic[&apos;I&apos;] = 1 dic[&apos;V&apos;] = 5 dic[&apos;X&apos;] = 10 dic[&apos;L&apos;] = 50 dic[&apos;C&apos;] = 100 dic[&apos;D&apos;] = 500 dic[&apos;M&apos;] = 1000 arr := []rune(s) var result = dic[arr[0]] for i := 1; i &lt; len(arr); i++ &#123; cur := dic[arr[i]] previous := dic[arr[i-1]] if cur &lt;= previous &#123; result += cur &#125; else &#123; result -= previous &lt;&lt; 1 result += cur &#125; &#125; return result&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode014","slug":"leetcode014","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode014/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode014/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport &quot;fmt&quot;/*给定一个String类型数组，要求写一个方法，返回数组中这些字符串的最长公共前缀。举个例子：假如数组为[&quot;123&quot;,&quot;12&quot;,&quot;4&quot;]，经过这个方法返回的结果就应该是&quot;&quot;。因为&quot;123&quot;，&quot;12&quot;，&quot;4&quot;并没有共同的前缀，虽然&quot;123&quot;，&quot;12&quot;的公共最长前缀是&quot;12&quot;，但是这个公共前缀&quot;12&quot;与&quot;4&quot;没有公共前缀，所以最后返回的结果就是&quot;&quot;。*/func main() &#123; var strs = []string&#123;&quot;c&quot;,&quot;c&quot;&#125; fmt.Printf(&quot;%s&quot;, longestCommonPrefix(strs))&#125;func longestCommonPrefix(strs []string) string &#123; if len(strs) == 0 || strs[0] == &quot;&quot; &#123; return &quot;&quot; &#125; if len(strs)==1 &#123; return strs[0] &#125; str := strs[0] index := 0 var res []byteLabel: for &#123; if index &lt; len(str) &#123; simple := str[index] for i := 1; i &lt; len(strs); i++ &#123; if index &lt; len(strs[i]) &#123; char := strs[i][index] if char != simple &#123; break Label &#125; &#125; else &#123; break Label &#125; &#125; res = append(res, simple) &#125;else&#123; break &#125; index++ &#125; return string(res)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode015","slug":"leetcode015","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode015/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode015/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package mainimport ( &quot;fmt&quot; &quot;sort&quot;)/*Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]]*/func threeSum(nums []int) [][]int &#123; sort.Ints(nums) var data map[int][]int data = make(map[int][]int) var result [][]int //var result [][]int for i := 0; i &lt; len(nums); i++ &#123; _, ok := data[nums[i]] if ok &#123; fmt.Printf(&quot;%v contains \\n&quot;, nums[i]) continue &#125; else &#123; target := -nums[i] //fmt.Printf(&quot;target %v \\n&quot;, target) subn := nums[i+1:] m := make(map[int]int, len(subn)) for subi := 0; subi &lt; len(subn); subi++ &#123; v, has := m[target-subn[subi]] if has &#123; v1, has1 := data[nums[i]] if has1 &#123; if v1[0] != subn[v] &amp;&amp; v1[0] != subn[subi] &#123; result = append(result, []int&#123;nums[i], subn[v], subn[subi]&#125;) data[nums[i]] = []int&#123;subn[v], subn[subi]&#125; &#125; &#125; else &#123; result = append(result, []int&#123;nums[i], subn[v], subn[subi]&#125;) data[nums[i]] = []int&#123;subn[v], subn[subi]&#125; &#125; /*result = append(result, []int&#123;nums[i], subn[v], subn[subi]&#125;) data[nums[i]] = []int&#123;subn[v], subn[subi]&#125; */ &#125; m[subn[subi]] = subi &#125; &#125; &#125; //fmt.Printf(&quot;%v&quot;, result) return result&#125;func twoSum(nums []int, target int) []int &#123; m := make(map[int]int, len(nums)) for i, num := range nums &#123; v, has := m[target-nums[i]] if has &#123; var result []int = []int&#123;v, i&#125; return result &#125; m[num] = i &#125; return nil&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode020","slug":"leetcode020","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode020/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode020/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;&#123;&apos;, &apos;&#125;&apos;, &apos;[&apos; and &apos;]&apos;,determine if the input string is valid.The brackets must close in the correct order,&quot;()&quot; and &quot;()[]&#123;&#125;&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not.*/package mainimport ( &quot;container/list&quot;)func main() &#123; print(isValid(&quot;[()]&quot;))&#125;func isValid(s string) bool &#123; operatorStack := list.New() for _, v := range s &#123; if v == &apos;(&apos; || v == &apos;&#123;&apos; || v == &apos;[&apos; &#123; operatorStack.PushFront(v) &#125; else if v == &apos;)&apos; &#123; front := operatorStack.Front() if front != nil &#123; if front.Value.(int32) == &apos;(&apos; &#123; operatorStack.Remove(operatorStack.Front()) &#125; else &#123; return false &#125; &#125; else &#123; return false &#125; &#125; else if v == &apos;]&apos; &#123; front := operatorStack.Front() if front != nil &#123; if front.Value.(int32) == &apos;[&apos; &#123; operatorStack.Remove(operatorStack.Front()) &#125; else &#123; return false &#125; &#125; else &#123; return false &#125; &#125; else if v == &apos;&#125;&apos; &#123; front := operatorStack.Front() if front != nil &#123; if front.Value.(int32) == &apos;&#123;&apos; &#123; operatorStack.Remove(operatorStack.Front()) &#125; else &#123; return false &#125; &#125; else &#123; return false &#125; &#125; &#125; if operatorStack.Front() != nil &#123; return false &#125; return true&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode026","slug":"leetcode026","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode026/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode026/","excerpt":"","text":"1234567891011121314151617package mainimport ( &quot;fmt&quot;)func removeDuplicates(nums []int) int &#123; index := 1 for i := 1; i &lt; len(nums); i++ &#123; if nums[index] != nums[i-1] &#123; nums[index] = nums[i] index++ &#125; &#125; fmt.Printf(&quot;%v&quot;, nums) return index&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode027","slug":"leetcode027","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode027/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode027/","excerpt":"","text":"12345678910111213141516package main//3,2,2,3//2,2,3,3func removeElement(nums []int, val int) int &#123; //index := 1 lastindex := 0 for i := 0; i &lt; len(nums); i++ &#123; if nums[i] != val &#123; nums[lastindex] = nums[i] lastindex++ &#125; &#125; return lastindex&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode021","slug":"leetcode021","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode021/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode021/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637package main/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; var res = &amp;ListNode&#123;-1, nil&#125; var dummy = res for l1 != nil &amp;&amp; l2 != nil &#123; l1Value := l1.Val l2Value := l2.Val if l1Value &lt; l2Value &#123; dummy.Next = l1 l1 = l1.Next &#125; else &#123; dummy.Next = l2 l2 = l2.Next &#125; dummy = dummy.Next &#125; if l1 != nil &#123; dummy.Next = l1 &#125; else &#123; dummy.Next = l2 &#125; return res.Next&#125;func main() &#123;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode035","slug":"leetcode035","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode035/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode035/","excerpt":"","text":"12345678910111213141516171819202122232425package mainfunc SearchInsert(nums []int, target int) int &#123; if len(nums) == 1 &#123; if target &gt; nums[0] &#123; return 1 &#125; else &#123; return 0 &#125; &#125; for i := 1; i &lt; len(nums); i++ &#123; if target == nums[i] &#123; return i &#125; else if target &lt; nums[i] &#123; if target &gt; nums[i-1] &#123; return i &#125; else &#123; return i - 1 &#125; &#125; &#125; return len(nums)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode001","slug":"leetcode001","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode001/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode001/","excerpt":"","text":"1234567891011121314151617package mainfunc twoSum(nums []int, target int) []int &#123; m := make(map[int]int, len(nums)) for i, num := range nums &#123; v, has := m[target-nums[i]] if has &#123; var result []int = []int&#123;v, i&#125; return result &#125; m[num] = i &#125; return nil&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode053","slug":"leetcode053","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode053/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode053/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot;)/*Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6.*/func main() &#123; fmt.Printf(&quot;%v&quot;, maxSubArray([]int&#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;))&#125;func maxSubArray(nums []int) int &#123; const MaxUint = ^uint(0) const MinUint = 0 const MaxInt = int(MaxUint &gt;&gt; 1) const MinInt = -MaxInt - 1 var curSum int var maxSum int = MinInt for i := 0; i &lt; len(nums); i++ &#123; if curSum &lt;= 0 &#123; curSum = nums[i] &#125; else &#123; curSum += nums[i] &#125; fmt.Printf(&quot;%v \\n&quot;, curSum) //fmt.Printf(&quot;cur %v i %v \\n&quot;, curSum, nums[i]) if curSum &gt; maxSum &#123; maxSum = curSum &#125; &#125; return maxSum&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode006","slug":"leetcode006","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode006/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode006/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041package main/* 1 7 2 6 8 3 5 9 4 10*/func convert(s string, numRows int) string &#123; if numRows == 1 &#123; return s &#125; var arr []byte for i := 0; i &lt; numRows; i++ &#123; dis := 2 * (numRows - 1) var dis2 int if i == 0 &#123; dis2 = dis &#125; else &#123; dis2 = dis - 2*i &#125; for j := i; j &lt; len(s); j += dis &#123; arr = append(arr, s[j]) if i &gt; 0 &amp;&amp; i &lt; numRows-1 &#123; temp := j + dis2 if temp &lt; len(s) &#123; arr = append(arr, s[temp]) &#125; &#125; &#125; &#125; return string(arr)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode054","slug":"leetcode054","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode054/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode054/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( &quot;fmt&quot;)/*Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]*/func spiralOrder(matrix [][]int) []int &#123; var res []int if len(matrix) == 0 &#123; return res &#125; x := 0 y := 0 carryX := 0 carryY := 0 endX := len(matrix[0]) - 1 endY := len(matrix) - 1 plus := true res = append(res, matrix[x][y]) for i := 1; len(res) &lt; len(matrix)*len(matrix[0]); i++ &#123; if plus &#123; if x &lt; endX &#123; x++ &#125; else if y &lt; endY &#123; y++ &#125; else &#123; plus = false carryY++ endX = carryX endY = carryY x-- &#125; &#125; else &#123; if x &gt; endX &#123; x-- &#125; else if y &gt; endY &#123; y-- &#125; else &#123; plus = true carryX++ endX = len(matrix[0]) - carryX - 1 endY = len(matrix) - carryY - 1 x++ &#125; &#125; res = append(res, matrix[y][x]) &#125; return res&#125;/*1 23*/func main() &#123; var quiz [][]int //quiz = append(quiz, []int&#123;3&#125;) //quiz = append(quiz, []int&#123;2&#125;) quiz = append(quiz, []int&#123;12, 13, 14, 44, 55&#125;) quiz = append(quiz, []int&#123;11, 3, 5, 2, 66&#125;) quiz = append(quiz, []int&#123;11, 1, 6, 7, 66&#125;) quiz = append(quiz, []int&#123;11, 3, 9, 1, 66&#125;) quiz = append(quiz, []int&#123;11, 5, 15, 77, 66&#125;) res := spiralOrder(quiz) for _, v := range res &#123; fmt.Printf(&quot;%v &quot;, v) &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode058","slug":"leetcode058","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode058/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode058/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;bytes&quot; &quot;fmt&quot;)/*Given a string s consists of upper/lower-case alphabets and empty space characters &apos; &apos;, return the length of last word in the string.If the last word does not exist, return 0.Note: A word is defined as a character sequence consists of non-space characters only.For example,Given s = &quot;Hello World&quot;,return 5.*/func lengthOfLastWord(s string) int &#123; //fmt.Printf(&quot;%v&quot;, []byte(s)) //fmt.Printf(&quot;s %v \\n&quot;, s) length := 0 bt := []byte(s) bt = bytes.Trim(bt, &quot; &quot;) for i, v := range bt &#123; if i == len(bt)-1 &#123; if v != 32 &#123; length++ &#125; &#125; else if v == 32 &#123; length = 0 &#125; else &#123; length++ &#125; &#125; return length&#125;func main() &#123; fmt.Printf(&quot;%v&quot;, lengthOfLastWord(&quot;b a &quot;))&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode066","slug":"leetcode066","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode066/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode066/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot;)/*Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.You may assume the integer do not contain any leading zero, except the number 0 itself.The digits are stored such that the most significant digit is at the head of the list.*/func main() &#123; //var i uint //count := 0 /*for i = 32; i != 0; i-- &#123; if num&gt;&gt;i&amp;1 == 0 &#123; continue &#125; fmt.Printf(&quot;%v &quot;, num&gt;&gt;i&amp;1) &#125;*/ //fmt.Printf(&quot;%v&quot;, plusOne([]int&#123;1, 0, 0, 1, 1&#125;)) fmt.Printf(&quot;%v&quot;, plusOne([]int&#123;3, 9, 9&#125;))&#125;//2,9,9func plusOne(digits []int) []int &#123; carry := 1 var res []int res = make([]int, len(digits)) for i := len(digits) - 1; i &gt;= 0; i-- &#123; temp := digits[i] + carry if temp == 10 &#123; res[i] = 0 &#125; else &#123; carry = 0 res[i] = temp &#125; if i == 0 &amp;&amp; carry == 1 &#123; temp := make([]int, len(res)+1) temp[0] = 1 for i := 1; i &lt; len(temp); i++ &#123; temp[i] = res[i-1] &#125; return temp &#125; &#125; return res&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode069","slug":"leetcode069","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode069/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode069/","excerpt":"","text":"123456789101112131415161718package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Printf(&quot;%v&quot;, mySqrt(2147395599))&#125;func mySqrt(x int) int &#123; var z float64 z = 10 for i := 0; i &lt; 100; i++ &#123; z -= ((z*z - float64(x)) / (2 * z)) &#125; return int(z)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode067","slug":"leetcode067","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode067/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode067/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package main/*Given two binary strings, return their sum (also a binary string).For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;.*/func addBinary(a string, b string) string &#123; var arr_a []byte var arr_b []byte if len(a) &gt; len(b) &#123; arr_a = []byte(a) arr_b = []byte(b) &#125; else &#123; arr_a = []byte(b) arr_b = []byte(a) &#125; var result []byte i := len(arr_a) - 1 j := len(arr_b) - 1 carry := 0 for i &gt;= 0 &amp;&amp; j &gt;= 0 &#123; temp := arr_a[i] + arr_b[j] + byte(carry) if temp &gt;= byte(98) &#123; result = append(result, 48+temp%98) if carry == 0 &#123; carry++ &#125; &#125; else &#123; result = append(result, temp-48) if carry &gt; 0 &#123; carry-- &#125; &#125; fmt.Printf(&quot;%v %v \\n&quot;, result, carry) i-- j-- &#125; for i := len(arr_a) - len(arr_b) - 1; i &gt;= 0; i-- &#123; temp := arr_a[i] sum := temp + byte(carry) if sum &gt;= 50 &#123; result = append(result, 48+(50-sum)) if carry == 0 &#123; carry++ &#125; &#125; else &#123; result = append(result, sum) if carry &gt; 0 &#123; carry-- &#125; &#125; &#125; for carry &gt; 0 &#123; result = append(result, 49) carry-- &#125; return reverse(string(result))&#125;func reverse(str string) string &#123; var res []byte temp := []byte(str) for i := len(temp) - 1; i &gt;= 0; i-- &#123; res = append(res, temp[i]) &#125; return string(res)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode070","slug":"leetcode070","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode070/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode070/","excerpt":"","text":"12345678910111213141516171819202122package mainfunc main() &#123; print(climbStairs(1000))&#125;var dummy map[int]int = make(map[int]int)func climbStairs(n int) int &#123; if n == 1 || n == 2 || n == 0 &#123; return n &#125; _, ok := dummy[n] if ok &#123; return dummy[n] &#125; else &#123; dummy[n] = climbStairs(n-1) + climbStairs(n-2) return dummy[n] &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode083","slug":"leetcode083","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode083/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode083/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package main/*import ( &quot;fmt&quot;)*/func main() &#123; head := ListNode&#123;1, nil&#125; generate(&amp;head, 1) generate(&amp;head, 1) deleteDuplicates(&amp;head) printLink(&amp;head)&#125;/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123; if head == nil &#123; return nil &#125; if head.Next == nil &#123; return head &#125; previous := head var current *ListNode = previous.Next for current != nil &#123; curVal := current.Val preVal := previous.Val if preVal == curVal &#123; if current.Next != nil &#123; previous.Next = current.Next current = current.Next continue &#125; else &#123; previous.Next = nil &#125; &#125; previous = current current = current.Next &#125; return head&#125;func generate(head *ListNode, val int) &#123; temp := head for temp.Next != nil &#123; temp = temp.Next &#125; temp.Next = &amp;ListNode&#123;val, nil&#125;&#125;func printLink(head *ListNode) *ListNode &#123; temp := head for temp != nil &#123; print(temp.Val) temp = temp.Next &#125; return head&#125;type ListNode struct &#123; Val int Next *ListNode&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode088","slug":"leetcode088","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode088/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode088/","excerpt":"","text":"123456789101112131415161718package mainfunc merge(nums1 []int, m int, nums2 []int, n int) &#123; for j := 0; j &lt; n; j++ &#123; nums1[m+j] = nums2[j] &#125; for i := 0; i &lt; m+n; i++ &#123; for j := i + 1; j &lt; m+n; j++ &#123; if nums1[i] &gt; nums1[j] &#123; nums1[i], nums1[j] = nums1[j], nums1[i] &#125; &#125; &#125; //fmt.Printf(&quot;%v&quot;, nums1)&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode167","slug":"leetcode167","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode167/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode167/","excerpt":"","text":"12345678910111213141516171819package mainfunc twoSum(numbers []int, target int) []int &#123; m := make(map[int]int) for i, v := range numbers &#123; _, ok := m[target-v] if ok &#123; res := []int&#123;m[target-v] + 1, i + 1&#125; return res &#125; else &#123; m[v] = i &#125; &#125; return nil&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode118","slug":"leetcode118","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode118/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode118/","excerpt":"","text":"123456789101112131415161718192021222324package main/*import ( &quot;fmt&quot;)*/func Generate(numRows int) [][]int &#123; var arr [][]int if numRows == 0 &#123; return arr &#125; arr = append(arr, []int&#123;1&#125;) for i := 1; i &lt; numRows; i++ &#123; var temp []int temp = append(temp, 1) for j := 1; j &lt; i; j++ &#123; temp = append(temp, arr[i-1][j-1]+arr[i-1][j]) &#125; temp = append(temp, 1) arr = append(arr, temp) &#125; return arr&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode217","slug":"leetcode217","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode217/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode217/","excerpt":"","text":"1234567891011121314151617package mainfunc containsDuplicate(nums []int) bool &#123; m := make(map[int]int) for _, v := range nums &#123; _, ok := m[v] if ok &#123; return true &#125; else &#123; m[v] = 1 &#125; &#125; return false&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode371","slug":"leetcode371","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode371/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode371/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot;)func add(a, b int) int &#123; v := a v1 := b for v1 != 0 &#123; temp := v ^ v1 temp1 := (v &amp; v1) &lt;&lt; 1 v = temp v1 = temp1 &#125; return v&#125;/*01101100001101101110001110011010000*/","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode002","slug":"leetcode002","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode002/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode002/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport &quot;fmt&quot;func main() &#123; var head = &amp;ListNode&#123;9, nil&#125; generate(head, 1) generate(head, 6) //generate(head, 9) var head1 = &amp;ListNode&#123;0, nil&#125; //generate(head1, 3) //generate(head1, 8) //generate(head1, 1) //printLink(head) println() //printLink(head1) println() numbers := addTwoNumbers(head, head1) printLink(numbers)&#125;func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var carry = 0 var head = ListNode&#123;-1, nil&#125; var res = &amp;head for l1 != nil &amp;&amp; l2 != nil &#123; temp := l1.Val + l2.Val + carry if temp &gt; 9 &#123; if res.Val == -1 &#123; res.Val = temp - 10 &#125; else &#123; res.Next = &amp;ListNode&#123;temp - 10, nil&#125; res = res.Next &#125; if carry==0&#123; carry++ &#125; &#125; else &#123; if res.Val == -1 &#123; res.Val = temp &#125; else &#123; res.Next = &amp;ListNode&#123;temp, nil&#125; res = res.Next if carry &gt; 0 &#123; carry-- &#125; &#125; &#125; fmt.Printf(&quot;\\n %v %v %v %v&quot;, l1.Val, l2.Val, res.Val, temp) if res.Next != nil &#123; fmt.Printf(&quot;\\n next %v&quot;, res.Next.Val) &#125; l1 = l1.Next l2 = l2.Next &#125; for l1 != nil &#123; temp := l1.Val + carry fmt.Printf(&quot;\\n carry %v&quot;,carry) if temp &gt; 9 &#123; res.Next = &amp;ListNode&#123;temp - 10, nil&#125; res = res.Next &#125; else &#123; res.Next = &amp;ListNode&#123;temp, nil&#125; res = res.Next if carry&gt;0 &#123; carry-- &#125; &#125; l1 = l1.Next &#125; for l2 != nil &#123; temp := l2.Val + carry if temp &gt; 9 &#123; res.Next = &amp;ListNode&#123;temp - 10, nil&#125; res = res.Next &#125; else &#123; res.Next = &amp;ListNode&#123;temp, nil&#125; res = res.Next if carry&gt;0 &#123; carry-- &#125; &#125; l2 = l2.Next &#125; for carry &gt; 0 &#123; res.Next = &amp;ListNode&#123;1, nil&#125; res = res.Next carry-- &#125; return &amp;head&#125;func generate(head *ListNode, val int) &#123; temp := head for temp.Next != nil &#123; temp = temp.Next &#125; temp.Next = &amp;ListNode&#123;val, nil&#125;&#125;func printLink(head *ListNode) &#123; temp := head for temp != nil &#123; print(temp.Val) temp = temp.Next &#125;&#125;type ListNode struct &#123; Val int Next *ListNode&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode004","slug":"leetcode004","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode004/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode004/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;fmt&quot; &quot;sort&quot;)/*There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5*/func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; var temp []int res := float64(0) for _, v := range nums1 &#123; temp = append(temp, v) &#125; for _, v := range nums2 &#123; temp = append(temp, v) &#125; sort.Ints(temp) if len(temp)%2 == 0 &#123; left := float64(temp[len(temp)/2]) right := float64(temp[len(temp)/2-1]) res = (left + right) / 2 &#125; else &#123; res = float64(temp[len(temp)/2]) &#125; return res&#125;func main() &#123; fmt.Printf(&quot;%v&quot;, findMedianSortedArrays([]int&#123;1, 3&#125;, []int&#123;2&#125;))&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode005","slug":"leetcode005","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode005/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode005/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142package mainfunc longestPalindrome(s string) string &#123; var str string if len(s) == 1 &#123; return s &#125; for i := 0; i &lt; len(s)-1; i++ &#123; res := search(i, i, s) //fmt.Printf(&quot;left %v right %v res %v \\n&quot;, i, i, res) if len(res) &gt; len(str) &#123; str = res &#125; if i != len(s)-1 &#123; res1 := search(i, i+1, s) //fmt.Printf(&quot;left %v right %v res %v \\n&quot;, i, i+1, res1) if len(res1) &gt; len(str) &#123; str = res1 &#125; &#125; &#125; return str&#125;func search(left, right int, s string) string &#123; for left &gt;= 0 &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == s[right] &#123; //fmt.Printf(&quot;%v %v %v\\n&quot;, left, right, s) left-- right++ &#125; //fmt.Printf(&quot;left %v right %v \\n&quot;, left, right) return s[left+1 : right]&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode007","slug":"leetcode007","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode007/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode007/","excerpt":"","text":"12345678910111213package mainfunc reverse(x int) int &#123; res := 0 for x != 0 &#123; res = res*10 + x%10 x /= 10 &#125; return res&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]},{"title":"leetcode038","slug":"leetcode038","date":"2018-01-18T05:38:08.000Z","updated":"2018-01-18T05:38:08.000Z","comments":true,"path":"2018/01/18/leetcode038/","link":"","permalink":"http://www.songyuqiang.com/2018/01/18/leetcode038/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*The count-and-say sequence is the sequence of integers with the first five terms as following:1. 12. 113. 214. 12115. 1112211 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth term of the count-and-say sequence.Note: Each term of the sequence of integers will be represented as a string.Example 1:Input: 1Output: &quot;1&quot;Example 2:Input: 4Output: &quot;1211&quot;*//*111211211111221*/package mainimport ( &quot;fmt&quot;)func main() &#123; print(countAndSay(6))&#125;func countAndSay(count int) string &#123; var res string = &quot;1&quot; for count &gt; 1 &#123; res = say(res) count-- print(res + &quot;\\n&quot;) &#125; return res&#125;func say(str string) string &#123; var arr = []byte(str) var res string count := 1 for i := 0; i &lt; len(arr); i++ &#123; previous := arr[i] if i+1 &lt; len(arr) &#123; current := arr[i+1] if current == previous &#123; count++ &#125; else &#123; res = res + fmt.Sprint(count) res = res + string(previous) count = 1 &#125; &#125; else &#123; res = res + fmt.Sprint(count) res = res + string(previous) &#125; &#125; return res&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.songyuqiang.com/tags/leetcode/"}]}]}